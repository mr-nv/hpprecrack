#include "crypto.h"
#include <vector>

namespace crypto
{
	void Xor( std::string& msg )
	{
		const char key[ ] = { 0x52, 0x4D, 0x6E, 0x78, 0x36, 0x25, 0x2A, 0x54, 0x38, 0x33, 0x59, 0x37, 0x41, 0x42, 0x48, 0x73, 0x6A, 0x75, 0x7E, 0x68, 0x72, 0x53, 0x34, 0x5A, 0x6F, 0x57, 0x64, 0x47, 0x79, 0x46, 0x65, 0x7B, 0x71, 0x4B, 0x69, 0x35, 0x30, 0x77, 0x74, 0x4A, 0x7A, 0x57, 0x76, 0x23, 0x34, 0x74, 0x43, 0x67, 0x63, 0x7B, 0x43, 0x30, 0x61, 0x73, 0x25, 0x43, 0x6F, 0x7D, 0x64, 0x68, 0x34, 0x3F, 0x67, 0x7E, 0x42, 0x61, 0x49, 0x7E, 0x52, 0x44, 0x62, 0x38, 0x46, 0x32, 0x58, 0x66, 0x33, 0x5A, 0x6A, 0x4C, 0x57, 0x70, 0x6B, 0x40, 0x47, 0x68, 0x7A, 0x64, 0x4B, 0x51, 0x45, 0x77, 0x56, 0x25, 0x31, 0x75, 0x73, 0x76, 0x74, 0x67, 0x79, 0x4A, 0x53, 0x36, 0x49, 0x78, 0x23, 0x4F, 0x57, 0x52, 0x64, 0x24, 0x43, 0x54, 0x61, 0x79, 0x6A, 0x38, 0x6E, 0x7C, 0x46, 0x62, 0x7A, 0x62, 0x35, 0x31, 0x4E, 0x7E, 0x5A, 0x71, 0x74, 0x77, 0x37, 0x64, 0x6B, 0x4B, 0x57, 0x3F, 0x7E, 0x38, 0x76, 0x6F, 0x4C, 0x75, 0x70, 0x41, 0x67, 0x6C, 0x63, 0x6E, 0x7D, 0x78, 0x58, 0x42, 0x31, 0x30, 0x51, 0x7B, 0x72, 0x34, 0x23, 0x53, 0x68, 0x45, 0x65, 0x69, 0x33, 0x61, 0x48, 0x24, 0x2A, 0x79, 0x50, 0x46, 0x71, 0x63, 0x6B, 0x44, 0x3F, 0x73, 0x66, 0x44, 0x74, 0x7E, 0x40, 0x39, 0x69, 0x51, 0x6A, 0x7A, 0x31, 0x6E, 0x40, 0x53, 0x64, 0x67, 0x52, 0x37, 0x44, 0x4F, 0x49, 0x6A, 0x38, 0x66, 0x4D, 0x59, 0x61, 0x65, 0x41, 0x6D, 0x75, 0x7B, 0x57, 0x4E, 0x23, 0x50, 0x79, 0x71, 0x69, 0x78, 0x4B, 0x76, 0x7C, 0x6B, 0x73, 0x46, 0x34, 0x56, 0x42, 0x6E, 0x7A, 0x54, 0x77, 0x55, 0x41, 0x51, 0x64, 0x42, 0x50, 0x76, 0x25, 0x41, 0x49, 0x64, 0x52, 0x31, 0x79, 0x7E, 0x70, 0x48, 0x30, 0x73, 0x55, 0x48, 0x7B, 0x7D };

		for( size_t i = 0; i < msg.size( ); i++ )
			msg[ i ] ^= key[ i % sizeof( key ) ];
	}

	// pasted
	static constexpr auto base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	void Base64Encode( std::string& str )
	{
		std::string out;

		int val = 0, valb = -6;

		for( unsigned char c : str )
		{
			val = ( val << 8 ) + c;
			valb += 8;

			while( valb >= 0 )
			{
				out.push_back( base64_chars[ ( val >> valb ) & 0x3F ] );
				valb -= 6;
			}
		}

		if( valb > -6 )
			out.push_back( base64_chars[ ( ( val << 8 ) >> ( valb + 8 ) ) & 0x3F ] );

		while( out.size( ) % 4 )
			out.push_back( '=' );

		str = out;
	}

	void Base64Decode( std::string& str )
	{
		std::string out;

		std::vector< int > T( 256, -1 );

		for( int i = 0; i < 64; i++ )
			T[ base64_chars[ i ] ] = i;

		int val = 0, valb = -8;

		for( unsigned char c : str )
		{
			if( T[ c ] == -1 )
				break;

			val = ( val << 6 ) + T[ c ];
			valb += 6;

			if( valb >= 0 )
			{
				out.push_back( char( ( val >> valb ) & 0xFF ) );
				valb -= 8;
			}
		}

		str = out;
	}

	static const char* const szLut = "0123456789ABCDEF";
	std::string HexToString( const std::string& in )
	{
		if( in.length( ) & 1 )
			return in;

		std::string sOutPut;

		sOutPut.reserve( in.length( ) / 2 );

		for( size_t i = 0; i < in.length( ); i += 2 )
		{
			auto a = in[ i ];
			auto p = std::lower_bound( szLut, szLut + 16, a );

			if( *p != a )
				return in;

			auto b = in[ i + 1 ];
			auto q = std::lower_bound( szLut, szLut + 16, b );

			if( *q != b )
				return in;

			sOutPut.push_back( ( ( p - szLut ) << 4 ) | ( q - szLut ) );
		}

		return sOutPut;
	}

	void EncryptServerHWIDResponse( std::string& str )
	{
		for( int i = 0; i < 3; i++ )
		{
			Xor( str );
			Base64Encode( str );
		}
	}

	void DecryptClientHWIDResponse( std::string& str )
	{
		// skip header ("c2s_hwid:")
		str = str.substr( 9 );

		for( int i = 0; i < 3; i++ )
		{
			Base64Decode( str );
			str = HexToString( str );
			Xor( str );
		}
	}
}